use core::fmt::Write;
use thiserror::Error;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Codec {
    Pcmu,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct MediaDescription {
    pub port: u16,
    pub payload_type: u8,
    pub codec: Codec,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SessionDescription {
    pub origin: String,
    pub connection_address: String,
    pub media: MediaDescription,
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum SdpError {
    #[error("invalid SDP: {0}")]
    Invalid(&'static str),
    #[error("buffer too small")]
    Capacity,
}

impl SessionDescription {
    pub fn offer(origin: &str, address: &str, port: u16) -> Result<Self, SdpError> {
        let mut origin_buf = String::new();
        origin_buf.push_str(origin);

        let mut address_buf = String::new();
        address_buf
            .push_str(address);

        Ok(Self {
            origin: origin_buf,
            connection_address: address_buf,
            media: MediaDescription {
                port,
                payload_type: 0,
                codec: Codec::Pcmu,
            },
        })
    }

    pub fn answer(&self, address: &str, port: u16) -> Result<Self, SdpError> {
        //TODO: RFC 3264: If the answer is different from the offer in any way
        //      (different IP addresses, ports, etc.), the origin line MUST be
        //      different in the answer, since the answer is generated by a
        //      different entity. In that case, the version number in the "o="
        //      line of the answer is unrelated to the version number in the o
        //      line of the offer.
        SessionDescription::offer(&self.origin, address, port)
    }

    pub fn render(&self) -> Result<String, SdpError> {
        let mut out = String::new();
        writeln!(out, "v=0").map_err(|_| SdpError::Capacity)?;
        
        //TODO: "session ID" and "session version" should not both be `0`,
        //      it will work for now though.
        writeln!(out, "o={} 0 0 IN IP4 {}", self.origin, self.connection_address)
            .map_err(|_| SdpError::Capacity)?;
        writeln!(out, "s=-").map_err(|_| SdpError::Capacity)?;
        writeln!(out, "c=IN IP4 {}", self.connection_address).map_err(|_| SdpError::Capacity)?;
        writeln!(out, "t=0 0").map_err(|_| SdpError::Capacity)?;
        writeln!(
            out,
            "m=audio {} RTP/AVP {}",
            self.media.port, self.media.payload_type
        )
        .map_err(|_| SdpError::Capacity)?;
        writeln!(out, "a=rtpmap:{} PCMU/8000", self.media.payload_type)
            .map_err(|_| SdpError::Capacity)?;
        Ok(out)
    }
}

pub fn parse(input: &str) -> Result<SessionDescription, SdpError> {
    let mut origin: Option<String> = None;
    let mut address: Option<String> = None;
    let mut media_port: Option<u16> = None;

    // Payload type we will use for PCMU, if any
    let mut pcmu_pt = None;
    let mut saw_pcmu = false;

    for raw_line in input.lines() {
        let line = raw_line.trim_end_matches('\r');
        let mut parts = line.splitn(2, '=');
        let prefix = parts
            .next()
            .ok_or(SdpError::Invalid("missing prefix"))?;
        let rest = parts
            .next()
            .ok_or(SdpError::Invalid("missing value"))?;

        match prefix {
            "o" => {
                let fields: Vec<&str> = rest.split_whitespace().collect();
                if fields.len() < 6 {
                    return Err(SdpError::Invalid("origin line"));
                }
                let mut buf = String::new();
                buf.push_str(fields[0]);
                origin = Some(buf);
            }
            "c" => {
                let fields: Vec<&str> = rest.split_whitespace().collect();
                if fields.len() != 3 {
                    return Err(SdpError::Invalid("connection line"));
                }
                let mut buf = String::new();
                buf.push_str(fields[2]);
                address = Some(buf);
            }
            "m" => {
                let fields: Vec<&str> = rest.split_whitespace().collect();
                if fields.len() < 4 || fields[0] != "audio" {
                    return Err(SdpError::Invalid("media line"));
                }
                media_port = fields[1].parse().ok();
            }
            "a" => {
                if rest.starts_with("rtpmap:") {
                    // rest is like "rtpmap:0 PCMU/8000" or "rtpmap:101 telephone-event/8000"
                    let after = &rest["rtpmap:".len()..];
                    let mut comps = after.split_whitespace();
                    let pt = comps
                        .next()
                        .ok_or(SdpError::Invalid("rtpmap payload"))?;
                    let codec = comps
                        .next()
                        .ok_or(SdpError::Invalid("rtpmap codec"))?;

                    // We only support PCMU/8000; ignore other codecs.
                    if codec.to_ascii_uppercase().starts_with("PCMU/8000") {
                        pcmu_pt = pt.parse().ok();
                        saw_pcmu = true;
                    } else {
                        // Ignore telephone-event, G722, etc.
                    }
                }
            }
            _ => {}
        }
    }

    let origin = origin.ok_or(SdpError::Invalid("missing origin"))?;
    let connection_address = address.ok_or(SdpError::Invalid("missing address"))?;
    let port = media_port.ok_or(SdpError::Invalid("missing media port"))?;
    
    if !saw_pcmu {
        return Err(SdpError::Invalid("no supported codec (PCMU/8000) in SDP"));
    }

    let payload_type = pcmu_pt.ok_or(SdpError::Invalid("missing PCMU payload type"))?;

    let sdp = SessionDescription {
        origin,
        connection_address,
        media: MediaDescription {
            port,
            payload_type,
            codec: Codec::Pcmu,
        }
    };

    log::debug!("parsed:\r\n{:#?}", sdp);

    Ok(sdp)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn builds_and_renders_offer() {
        let offer = SessionDescription::offer("atom-echo", "192.0.2.10", 10000).unwrap();
        let rendered = offer.render().unwrap();
        assert!(rendered.contains("m=audio 10000 RTP/AVP 0"));
        assert!(rendered.contains("a=rtpmap:0 PCMU/8000"));
    }

    #[test]
    fn parses_minimal_sdp() {
        let raw = "\
v=0
o=atom-echo 0 0 IN IP4 192.0.2.10
s=-
c=IN IP4 192.0.2.10
t=0 0
m=audio 20000 RTP/AVP 0
a=rtpmap:0 PCMU/8000
";
        let parsed = parse(raw).unwrap();
        assert_eq!(parsed.media.port, 20000);
        assert_eq!(parsed.media.payload_type, 0);
        assert_eq!(parsed.media.codec, Codec::Pcmu);
    }
}
